# 가상 쓰레드 정리

## 1. 스레드 기본 개념

- **프로세스(Process)**: 실행 중인 프로그램 전체 (메모리·자원 포함)
- **스레드(Thread)**: 그 안에서 실제로 일을 처리하는 실행 흐름 (작업 단위)

 비유: 프로세스는 회사, 스레드는 회사 직원한 회사(프로세스) 안에 직원(스레드)이 여러 명일 수 있다.

---

## 2. 기존 자바 스레드 (플랫폼 스레드)

- 자바에서 `new Thread(...)`로 만드는 일반적인 스레드
- **운영체제(OS)**가 직접 관리
- 스레드 1개 만들 때 메모리(약 1MB)를 많이 소비함
- DB 조회, 파일 읽기 같은 **I/O 작업**에서 멈추면 → 스레드가 유휴 상태로 대기
- 그래서 **많이 만들기 어려움 (수천 ~ 수만개 한계)**

---

## 3. 가상 스레드(Virtual Thread)

- **JVM(자바 가상 머신)**이 관리하는 가벼운 스레드
- 실제 OS 스레드에 바로 연결되는 게 아니라,**"캐리어 스레드"**라는 운영체제 스레드 위에 **얹혀서 돌아감**
- 실행 중 I/O 대기(예: DB 응답 기다림)가 생기면 → 캐리어 스레드에서 분리되어 다른 스레드에 자원 양보
- 그래서 **한정된 OS 스레드로도 수십만 개 동시 실행 가능**

👉 한마디로: **"경량화된 효율적인 스레드"**

---

## 4. 코드 예시

```java
// 기존 스레드
Thread t1 = new Thread(() -> {
    System.out.println("Hello from platform thread");
});
t1.start();

// 가상 스레드
Thread t2 = Thread.ofVirtual().start(() -> {
    System.out.println("Hello from virtual thread");
});
t2.join();

```

---

## 5. 플랫폼 vs 가상 스레드

| 비교 항목 | 플랫폼 스레드 (기존) | 가상 스레드 |
| --- | --- | --- |
| 관리 | 운영체제(OS) | JVM(자바가상머신) |
| 개수 | 수천 개 한계 | 수십만 개 가능 |
| 블로킹 I/O | 스레드가 멈춘 채 대기 | OS 스레드 반납 후 다른 일 처리 |
| 코드 스타일 | 동기 코드 | 동기 코드 그대로 사용 가능 |
| 잘 맞는 작업 | CPU 계산 위주 | I/O 대기 위주 |

---

## 6. 사용/불가능 사례

---

- 티켓팅(콘서트/공연)
    
    **효과 큰 부분 (가상 스레드 잘 맞음)**
    
    - 대기열(순번/토큰), 로그인/인증, 공연 정보/좌석 조회
    - 이유: 대부분 **DB/네트워크 응답 기다림(I/O 대기)**이 많음
    - 가상 스레드는 기다리는 동안 다른 스레드가 그 자리를 활용해 효율적
    
    **효과 제한적인 부분**
    
    - 실제 구매 확정(좌석 점유, 결제) → **DB에서 동시에 같은 좌석 잡으려는 문제(락)**
    - 이건 스레드 문제가 아니라 **데이터 충돌** 문제 → 가상 스레드로 해결 불가

---

- 자동차 견적
    
    **효과 큰 부분 (조금 도움 됨)**
    
    - 외부 서비스(API) 여러 군데 동시에 호출할 때 (세금 계산, 보험 조회, 프로모션 등)
    - I/O가 여러 개 동시에 발생하면 → 가상 스레드가 효율적으로 처리
    
    **효과 제한적인 부분**
    
    - 실제 차량 가격 계산, 옵션 조합 시뮬레이션 → **CPU 계산 위주**
    - CPU는 코어 수가 한정되어 있어, 스레드 수를 늘려도 성능 향상 제한적

---

- 온라인 한정판
    
    **효과 큰 부분 (가상 스레드 잘 맞음)**
    
    - 상품 목록 조회, 상세 페이지 조회, 장바구니 보기
    - 한정판 오픈할 때 접속자가 많아도 → 가상 스레드로 연결 유지 가능
    
    **효과 제한적인 부분**
    
    - 결제/재고 차감 단계 → **트랜잭션(중복 방지 락)** 문제
    - 이건 데이터베이스 설계 문제라 가상 스레드로 해결 불가

---

- 예약(병원/식당)
    
    **효과 큰 부분 (가상 스레드 잘 맞음)**
    
    - 예약 가능한 시간/의사/지점 조회
    - 특정 시간대에 사용자가 몰려도 → 가상 스레드가 많은 연결 처리 가능
    
    **효과 제한적인 부분**
    
    - 예약 확정 단계 → "중복 예약 방지" 때문에 DB 락이 걸림
    - 이건 가상 스레드가 아니라 **DB 동시성 제어**가 핵심 문제

---

## 6-2. 도메인별 요약

| 도메인 | 효과 크기 | 이유 |
| --- | --- | --- |
| 티켓팅 | **큼** | 조회·대기(I/O 위주) |
| 자동차 견적 | **작음~중간** | 계산 위주(CPU 바운드) |
| 한정판 샵 | **중간** | 조회·대기엔 좋음, 결제는 제한 |
| 예약 | **큼** | 조회·대기(I/O 위주) |

---

## 7. 한 줄 정리

👉 **가상 스레드는 "기다리는 시간이 많은 서비스"에서 효과적이다.**

(티켓팅, 예약, 한정판 조회 등)

반면, **"계산 위주이거나 DB 락이 필요한 서비스"에서는 효과가 제한적이다.**

(자동차 견적 계산, 결제/재고 처리 등)