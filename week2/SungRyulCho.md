# 동시성 프로그래밍 모델 전격 비교: 플랫폼 스레드부터 Virtual Thread까지

# 서론: 왜 새로운 스레드 모델이 필요한가?

수많은 동시 요청을 처리해야 하는 현대 서버 환경에서, 기존의 "요청 당 스레드(Thread-per-Request)" 모델은 명확한 한계에 부딪혔습니다. 스레드를 하나 생성하는 데 드는 비용이 비싸고, 시스템의 메모리 제약으로 인해 생성할 수 있는 스레드 개수도 수천 개 수준으로 제한됩니다. 이러한 한계는 Java 생태계에만 머물고자 했던 팀조차 Kotlin의 코루틴을 대안으로 고려하게 만들었으며, 이는 Virtual Thread와 같은 네이티브 Java 솔루션의 필요성을 더욱 부각시켰습니다.

이러한 문제를 해결하기 위해 **'플랫폼 스레드', 'Virtual Thread', '코루틴', '리액티브 프로그래밍'** 이라는 4가지 주요 동시성 모델이 등장했습니다. 이 문서는 각 모델의 핵심 차이점을 명확히 비교하고, 어떤 상황에 어떤 모델이 가장 적합한지 한눈에 파악할 수 있도록 돕는 것을 목표로 합니다.

---

### 1. 기본 모델: 플랫폼 스레드 (Platform Thread)

플랫폼 스레드(Platform Thread)는 우리가 전통적으로 사용해 온 자바 스레드 모델로, 운영체제(OS)의 네이티브 스레드와 1:1로 매핑됩니다. 이는 **"한 명의 직원이 하나의 무거운 전용 장비를 사용하는 것"** 에 비유할 수 있습니다. 장비(OS 스레드)는 비싸고 개수가 한정되어, 직원이 잠시 자리를 비워도(I/O 대기) 장비는 계속 그 직원 차지가 되는 방식입니다.

플랫폼 스레드는 다음과 같은 주요 한계를 가집니다.

- **높은 생성 비용과 큰 메모리 공간** 스레드를 생성하기 위해 커널과 통신하는 시스템 콜(System Call)이 필요하며, 각 스레드는 약 1MB 이상의 스택 메모리를 차지합니다. 이 때문에 생성 비용이 비싸고 메모리 부담이 큽니다.
- **생성 가능한 개수의 한계** 제한된 메모리 환경(예: 4GB)에서는 생성할 수 있는 스레드의 수가 수천 개 수준으로 제한됩니다. 수만, 수십만 개의 동시 요청을 처리하기에는 역부족입니다.
- **I/O 작업 시 자원 낭비** 스레드가 데이터베이스 조회나 외부 API 호출과 같은 I/O 작업을 기다리며 대기(blocking) 상태에 빠지면, CPU는 아무 일도 하지 않음에도 불구하고 비싼 OS 스레드 자원은 계속 점유되는 비효율이 발생합니다.

이러한 플랫폼 스레드의 한계를 극복하기 위해 다양한 경량 스레드 모델과 비동기 프로그래밍 패러다임이 등장했습니다. 이제 각 모델을 하나씩 자세히 비교해 보겠습니다.

---

### 2. 주요 동시성 모델 비교 분석

아래 표는 4가지 주요 동시성 모델의 핵심 특징을 요약한 것입니다.

| 구분 항목       | 플랫폼 스레드 (Platform Thread)    | Virtual Thread              | 코루틴 (Coroutine)                 | 리액티브 프로그래밍 (Reactive)     |
| --------------- | ---------------------------------- | --------------------------- | ---------------------------------- | ---------------------------------- |
| **핵심 개념**   | OS 스레드와 1:1 매핑               | JVM이 관리하는 경량 스레드  | 컴파일러가 지원하는 경량 실행 단위 | 이벤트 루프 기반의 비동기/논블로킹 |
| **작동 방식**   | OS 스케줄러에 의한 컨텍스트 스위칭 | JVM 스케줄러의 park/unpark  | 컴파일러가 생성한 상태 머신        | 콜백 기반의 Worker 스레드 처리     |
| **코드 스타일** | 동기/블로킹 (절차적)               | 동기/블로킹 (절차적)        | `suspend` 키워드를 사용한 비동기   | `flatMap` 등 체이닝 기반의 비동기  |
| **'전염성'**    | 없음                               | 없음                        | 있음 (`suspend` 함수)              | 있음 (Reactive Streams)            |
| **디버깅**      | 쉬움 (스택 트레이스 명확)          | 쉬움 (스레드 컨텍스트 유지) | 상대적으로 어려움                  | 어려움 (스택 트레이스 유실)        |

### 2.1. 코드 작성 스타일의 차이점

각 모델은 코드 작성 방식에서 뚜렷한 차이를 보이며, 이는 개발 경험에 직접적인 영향을 미칩니다.

- **플랫폼 스레드 & Virtual Thread** "코드는 동기 방식처럼 간단하게 짜고, 성능은 비동기 방식처럼 뛰어나게"라는 목표를 공유합니다. 개발자는 기존의 직관적이고 절차적인 동기/블로킹 코드를 그대로 사용할 수 있어 가독성과 유지보수성이 뛰어납니다.
- **코루틴 (Coroutine)** `suspend` 키워드를 사용해 특정 메서드에만 경량 스레드 방식을 적용합니다. I/O 호출과 같이 컨텍스트 스위칭이 필요한 지점마다 `.await()`와 같은 별도의 확장 함수를 호출해야 합니다.
- **리액티브 프로그래밍 (Reactive)** `flatMap`, `map` 등 메서드를 연쇄적으로 호출하는 체이닝(Chaining) 방식으로 코드를 작성합니다. 로직이 여러 메서드로 파편화되어 전체적인 코드 흐름을 이해하기 어려울 수 있습니다.

### 2.2. 성능 비교: I/O Bound vs. CPU Bound

작업의 성격에 따라 각 모델의 성능은 크게 달라집니다.

- **I/O Bound 작업 (네트워크 통신, DB 조회 등)** 대부분의 시간을 I/O 대기에 사용하는 작업에서는 Virtual Thread가 압도적인 성능을 보입니다. Ngrinder를 활용한 성능 테스트 결과, Virtual Thread는 플랫폼 스레드 대비 **약 51% 이상**, 코루틴 대비 **37%**, 리액티브 프로그래밍 대비 **111%** 향상된 처리량을 기록했습니다.
- 여기서 플랫폼 스레드와의 51% 성능 차이는 실제보다 낮게 측정된 수치라는 점을 이해하는 것이 중요합니다. 테스트 시 가상 사용자(vuser) 수를 250명으로 제한해야 했는데, 이 수치를 넘어서자 플랫폼 스레드 모델의 서버가 다운되었기 때문입니다. 반면, Virtual Thread는 동일한 조건에서 장애 없이 요청을 정상 처리하며 높은 안정성을 보였습니다. 즉, 실제 성능 격차는 이보다 훨씬 클 가능성이 높습니다.
- **CPU Bound 작업 (암호화, 데이터 압축 등)** CPU를 끊임없이 사용하는 작업에서는 플랫폼 스레드가 Virtual Thread보다 더 나은 성능을 보입니다. Virtual Thread는 I/O 대기 시 컨텍스트 스위칭을 통해 이점을 얻는데, CPU Bound 작업에서는 이러한 스위칭이 거의 발생하지 않습니다. Java 공식 문서에서도 언급하듯이, "It is more expensive to run a task in a virtual thread than running it in a platform thread." 오히려 Virtual Thread 생성 및 스케줄링에 드는 추가 비용 때문에 성능이 저하될 수 있습니다.

### 2.3. 모델별 핵심 장단점

### Virtual Thread의 장점

1. **높은 처리량** I/O 바운드 작업에서 수백만 개의 스레드를 생성하여 시스템 처리량을 극대화할 수 있습니다.
2. **단순하고 직관적인 코드** 비동기 콜백이나 복잡한 체이닝 없이, 읽고 디버깅하기 쉬운 동기 스타일 코드를 그대로 유지할 수 있습니다.
3. **기존 코드와의 완벽한 호환성** 별도의 코드 수정 없이 기존의 스레드 기반 로직에 바로 적용할 수 있습니다. 또한, '전염성(함수의 색 문제)'이 없어 코드베이스 전체를 변경할 필요가 없습니다.

### 코루틴과 리액티브 프로그래밍의 상대적 장단점

- **코루틴 (Coroutine)**
  - **장점:** JDK 21 이전 버전에서도 경량 스레드를 사용할 수 있으며, 메서드 단위로 필요한 곳에만 선택적으로 적용할 수 있습니다.
  - **단점:** `suspend` 함수의 '전염성'으로 인해 관련 함수들도 모두 `suspend`로 만들어야 하며, Kotlin 언어에 대한 학습 곡선이 존재합니다.
- **리액티브 프로그래밍 (Reactive)**
  - **장점:** 적은 수의 스레드로 높은 처리량을 달성할 수 있습니다.
  - **단점:** '함수의 색 문제(전염성)'가 존재하며, 콜백 헬(Callback Hell)로 인해 코드가 복잡해집니다. 또한, 컨텍스트 스위칭 시 스택 트레이스가 유실되어 디버깅이 매우 어렵습니다.

지금까지 각 모델의 기술적 특성과 장단점을 비교해 보았습니다. 이를 바탕으로, 실제 개발 환경에서 어떤 기술을 선택해야 할지 구체적인 가이드라인을 제시하겠습니다.

---

### 3. 선택 가이드: 언제 어떤 모델을 사용해야 할까?

프로젝트의 특성과 요구사항에 따라 최적의 모델은 달라집니다.

- **플랫폼 스레드를 사용해야 할 때:** 암호화, 비디오 인코딩과 같이 I/O 대기 없이 CPU를 계속해서 집중적으로 사용하는 **CPU Bound 작업**에 가장 적합합니다.
- **Virtual Thread를 사용해야 할 때:** **대부분의 시간을 I/O 작업을 기다리는 다수의 동시 작업을 처리할 때** 가장 이상적입니다. (예: 마이크로서비스 API 핸들러, DB/외부 API 통신). 단순한 동기 코드 스타일을 유지하면서 높은 처리량을 원하는 Java 개발자에게, 이는 이제 **Java에서 I/O 집약적인 동시성 처리의 사실상 표준(de-facto standard)** 입니다.
- **코루틴을 사용해야 할 때:** **Kotlin이 프로젝트의 주요 개발 언어**이거나, **JDK 21 이전 버전의 Java 환경에서 경량 스레드**의 이점을 얻고 싶을 때 적합한 선택지입니다.
- **리액티브 프로그래밍을 사용해야 할 때:** 이미 팀이 **리액티브 패러다임에 매우 익숙**하고, 복잡한 비동기 이벤트 스트림을 정교하게 다루어야 하는 특정 상황에서 고려할 수 있습니다.

---

### 4. Virtual Thread 사용 시 핵심 주의사항

Virtual Thread는 강력한 도구이지만, 효과적으로 사용하기 위해 반드시 알아야 할 몇 가지 주의사항이 있습니다.

1. **스레드 풀링 금지 (No Pooling)** Virtual Thread는 생성 비용이 매우 저렴한 '일회용품'과 같습니다. 스레드 풀링의 목적은 OS 스레드처럼 생성 비용이 비싼 자원을 재사용하는 것인데, Virtual Thread는 이 전제에 해당하지 않습니다. 따라서 `Executors.newVirtualThreadPerTaskExecutor()`를 사용해 필요할 때마다 새로 생성하고, 작업이 끝나면 가비지 컬렉터(GC)에 의해 소멸되도록 두는 것이 가장 효율적인 표준 사용법입니다.
2. **Pinned Thread 현상 주의** Virtual Thread 내부에서 `synchronized` 블록, 네이티브 메서드(JNI), `parallelStream`을 호출하면, 스레드가 Carrier Thread(플랫폼 스레드)에 고정(pinning)되어 컨텍스트 스위칭이 불가능해집니다. 이는 Virtual Thread의 성능을 크게 저하시키므로, `synchronized` 대신 `java.util.concurrent.locks.ReentrantLock` 사용을 권장합니다.
3. **ThreadLocal 사용 최소화** Virtual Thread는 수백만 개까지 생성될 수 있습니다. 이때 `ThreadLocal` 변수가 너무 많은 메모리를 차지하면 심각한 메모리 문제를 일으킬 수 있습니다. 이를 '요요 현상'에 비유할 수 있습니다. 다이어트 후 다시 살이 찌는 요요 현상처럼, 크기가 큰 `ThreadLocal`을 가진 Virtual Thread가 수시로 생성되고 소멸되면 시스템의 메모리 사용량이 반복적으로 급증하며 불안정해질 수 있습니다. `ThreadLocal`은 항상 작은 크기로 유지해야 합니다.

---

### 결론: 현명한 동시성 모델 선택을 위하여

동시성 프로그래밍의 패러다임은 끊임없이 진화하고 있습니다. 특히 Java 진영에 등장한 Virtual Thread는 **'코드의 단순함'과 '높은 성능'** 이라는 두 마리 토끼를 동시에 잡을 수 있는 강력하고 혁신적인 대안으로 부상했습니다. 기존의 복잡한 비동기 코드 없이도 높은 처리량을 달성할 수 있게 된 것입니다.

프로젝트가 I/O 바운드 작업을 주로 다룬다면, 이제 Virtual Thread를 기본 동시성 모델로 고려하고, 복잡한 비동기 코드의 기술 부채에서 벗어날 기회를 잡아야 할 때입니다.
