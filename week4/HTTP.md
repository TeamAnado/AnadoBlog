# HTTP (HyperText Transfer Protocol)

## 1. HTTP 이전에: 인터넷 네트워크의 기초

HTTP는 인터넷에서 데이터를 주고받는 **약속(프로토콜)** 입니다. 작동하는지 알기 위해 기반이 되는 TCP/IP를 먼저 설명하겠습니다.

### IP (Internet Protocol)

- **역할:** 데이터가 찾아갈 **주소** (IP 주소)를 나타냅니다. 데이터를 '패킷(Packet)'이라는 작은 상자 단위로 쪼개어 전송합니다.
- **한계 (비연결성, 비신뢰성)**
  - IP는 '최선을 다하지만 보장하지 않는' 배송 시스템입니다.
  - 편지를 보낼 때 상대방이 집에 있는지 확인하지 않고(비연결성), 편지가 중간에 분실되거나, 여러 장을 보냈을 때 순서가 뒤바뀌어 도착할 수 있습니다(비신뢰성).

### TCP (Transmission Control Protocol)

- **역할:** IP의 한계를 보완하여, **신뢰할 수 있는** 데이터 전송을 보장합니다.
- **특징 (연결 지향)**
  - **[예시]** IP가 그냥 편지를 우체통에 넣는 것이라면, TCP는 **전화를 걸어 "지금부터 중요한 서류 보낼게요. 받을 준비되셨죠?"라고 확인(3-Way Handshake)** 하고 나서 보내는 것과 같습니다.
  - 서류 봉투에 **순서 번호(1/3, 2/3, 3/3)** 를 매깁니다. 중간에 2번 봉투가 사라지면, "2번 다시 보내주세요"라고 요청하여 데이터의 순서와 유실을 보장합니다.

### UDP (User Datagram Protocol)

- **특징:** TCP의 신뢰성 보장 과정(전화 걸기, 순서 매기기)을 모두 생략하고, 그냥 IP처럼 데이터를 '일단 던지는' 방식입니다. (하얀 도화지)
- **[예시]** 실시간 영상 스트리밍이나 온라인 게임처럼, 1~2프레임(패킷)이 중간에 사라져도 괜찮지만(신뢰성 낮음) 속도가 생명일 때(빠름) 사용합니다.

### DNS (Domain Name System)

- **역할:** `google.com` 같은 도메인 이름을 실제 서버의 IP 주소(`172.217.175.68`)로 변환해주는 '전화번호부' 시스템입니다.

---

## 2. HTTP의 핵심 특징

### ① 클라이언트-서버 구조

- 클라이언트(브라우저)가 요청(Request)을 보내고, 서버는 응답(Response)을 합니다.

### ② 무상태성 (Stateless)

- **의미:** 서버가 클라이언트의 이전 요청 상태를 기억하지 않습니다.
- **[예시: 푸드트럭 손님]**
  - **Stateless (무상태):** 푸드트럭 사장님은 손님(클라이언트)이 주문을 하고 음식을 받아 가면, 그 손님을 바로 잊어버립니다. 다음 손님을 응대해야 하니까요.
  - 만약 손님이 "아까 시킨 거에 감자튀김 추가요"라고 말하면, 사장님은 "아까 뭘 시키셨는데요?"라고 되물을 수밖에 없습니다.
  - **장점:** 사장님(서버)은 손님을 기억할 필요가 없어, 더 많은 손님을 빠르게 처리할 수 있습니다(확장성).
  - **단점:** 손님(클라이언트)은 매번 요청할 때마다 "저는 A세트에 콜라 시켰고요, 여기에 감자튀김 추가요"라고 모든 정보를 다 말해야 합니다.

#### 🤔 "로그인"은 무상태(Stateless)를 어떻게 해결할까? (쿠키와 세션)

무상태의 단점을 보완하기 위해 '상태 유지' 메커니즘이 필요합니다.

**방법 1. 쿠키와 세션 (서버에 상태 저장)**

**[예시: 테마파크 자유이용권]**

1.  **로그인 (POST /login):** 손님이 매표소(서버)에서 돈을 내고 자신을 인증합니다.
2.  **세션 생성 및 쿠키 발급 (Set-Cookie):** 매표소는 입장객 명단(세션)에 손님을 기록하고, "오늘 하루 이용 가능"이라고 적힌 **자유이용권 팔찌(쿠키)** 를 채워줍니다.
3.  **요청 (GET /rides/1):** 손님은 놀이기구를 탈 때마다, 이 **팔찌(쿠키)** 를 보여줍니다.
4.  **인증 (서버 세션 확인):** 놀이기구 직원(서버)은 팔찌를 보고, 매표소의 입장객 명단(세션)과 대조하여 "아, 입장권 산 손님 맞구나"라고 확인합니다.

- `쿠키(Cookie)`: 클라이언트(브라우저)에 저장되는 작은 데이터 조각 (자유이용권 팔찌)
- `세션(Session)`: 서버에 저장되는 실제 사용자 정보 (매표소의 입장객 명단)

**방법 2. 토큰 기반 인증 (JWT) (서버가 상태 저장 안 함)**

**[예시: 영화관 종이 티켓]**

1.  **로그인 (POST /login):** 사용자가 ID/PW로 매표소(서버)에 인증을 요청합니다.
2.  **토큰 발급 (JWT):** 서버는 사용자를 확인한 뒤, "A상영관, 3시 영화, 14번 좌석" 정보가 암호화된 **종이 티켓(Token)** 을 발급해 줍니다. (서버는 이 티켓을 따로 저장하지 않습니다.)
3.  **토큰 저장 (클라이언트):** 클라이언트는 이 티켓을 자신의 '지갑(브라우저 저장소)'에 잘 보관합니다.
4.  **요청 시 토큰 제출:** 클라이언트가 상영관에 입장할 때(API 요청 시)마다, HTTP 헤더에 이 **종이 티켓(Token)** 을 붙여서 보냅니다.
    - `Authorization: Bearer [아주 긴 토큰 값]`
5.  **토큰 검증 (서버):** 직원은 티켓을 보고 "아, 이 티켓은 위조되지 않았고, 유효한 티켓이 맞군"이라고 확인(검증)하고 들여보내 줍니다.

### ③ 비연결성 (Connectionless)

- **의미:** 서버가 클라이언트에게 응답을 보낸 후, 맺었던 연결(TCP)을 끊습니다.
- **장점:** 서버가 연결을 계속 유지하지 않아, 서버 자원을 효율적으로 사용합니다.
- **해결 (지속 연결, Persistent Connection) :** HTTP/1.1부터는 `Connection: keep-alive`를 통해, 요청이 잦을 경우 일정 시간 동안 연결을 끊지 않고 유지하는 기능이 기본값이 되었습니다.

---

## 3. HTTP의 역사와 발전

### HTTP/1.1 (현재의 표준)

- `PUT`, `DELETE` 등 다양한 메서드와 `HOST` 헤더, `지속 연결` 기능이 추가되었습니다.

**치명적 한계: HOL (Head-of-Line) Blocking - 예시: 1차선 도로**

- HTTP/1.1은 하나의 TCP 연결(도로)에서 요청과 응답이 **1:1로 순차적으로** 이루어집니다.
- 1차선 도로에서 앞 차(무거운 이미지 요청)가 느리게 가면, 뒤 차(가벼운 텍스트 요청)는 앞 차가 갈 때까지 무조건 기다려야 합니다. 이게 **HOL Blocking**입니다.

### HTTP/2 (성능 개선)

**해결: 멀티플렉싱 (Multiplexing) - 예시: 4차선 고속도로**

- HTTP/2는 하나의 TCP 연결(도로) 위를 **여러 개의 스트림(차선)** 으로 나눕니다.
- 이제 앞 차(이미지)가 느리게 가더라도, 뒤 차(텍스트)는 옆 차선(다른 스트림)으로 쌩하고 추월해 먼저 도착할 수 있습니다.

### HTTP/3 (미래의 표준)

- HTTP/2가 TCP 위에서 동작하는 한, TCP 레벨의 HOL Blocking(패킷 유실 시)은 여전히 존재했습니다.
- **QUIC 프로토콜:** TCP 대신 **UDP**를 기반으로 하여, 더 빠르고 안정적인 연결을 구현했습니다.

---

## 4. API와 HTTP 메서드

API는 '자원(Resource)'을 '어떻게(Method)' 다룰지 HTTP로 표현하는 방식입니다.

- **자원 (Resource):** `/members` (회원들), `/members/1` (1번 회원)
- **행위 (Method):** `GET`, `POST`, `PUT`, `PATCH`, `DELETE`

| 메서드     | 설명                                          | 멱등성(Idempotent) |
| :--------- | :-------------------------------------------- | :----------------- |
| **GET**    | 리소스 조회                                   | O                  |
| **POST**   | 리소스 생성 (주로 사용) / 데이터 처리         | X                  |
| **PUT**    | 리소스 **전체** 교체 (덮어쓰기). 없으면 생성. | O                  |
| **PATCH**  | 리소스 **일부** 수정                          | X (보장 안 됨)     |
| **DELETE** | 리소스 삭제                                   | O                  |

> **멱등성 (Idempotent) 이란?**
> 여러 번 호출해도 결과가 한 번 호출한 것과 같은 특성.
>
> **[예시: 엘리베이터 버튼]**
>
> - **멱등 (O) - `PUT`:** "10층 버튼 누르기" (`PUT /elevator/floor = 10`). 이 버튼을 한 번 누르든, 100번 누르든 '엘리베이터의 목적지는 10층'이라는 **결과는 동일**합니다.
> - **멱등 (X) - `POST`:** "피자 주문하기" (`POST /orders`). 이 요청을 한 번 하면 피자가 1판, 100번 하면 100판이 배달됩니다. **매번 결과가 달라집니다.**
> - **멱등 (X) - `PATCH`:** "현재 층에서 1층 올리기"
>   (`PATCH /elevator/floor += 1`). 이 요청을 한 번 하면 1층, 100번 하면 100층이 올라갑니다.

---

## 5. HTTP 상태 코드

서버가 클라이언트의 요청을 어떻게 처리했는지 알려주는 세 자리 숫자입니다.

### 2xx (Success) : 요청 성공

- `200 OK`: 요청 성공.
- `201 Created`: 리소스 생성 성공 (e.g., 회원가입 성공).
- `204 No Content`: 요청은 성공했으나, 응답 본문에 보낼 데이터가 없음.

<br>

### 3xx (Redirection) : 요청을 완료하려면 추가 동작이 필요.

**[핵심 예시: PRG (Post-Redirect-Get) 패턴]**

- **문제 상황:** 사용자가 '주문하기' 버튼(`POST`)을 누른 뒤, '주문 완료' 페이지에서 **새로고침(F5)** 을 누릅니다. 브라우저는 "POST 요청을 다시 보내시겠습니까?"라고 묻고, 사용자가 '예'를 누르면 **주문이 중복**됩니다.

**[해결 (PRG)]**

1.  **P (POST):** 클라이언트가 `POST /order`로 주문 요청.
2.  **R (Redirect):** 서버는 주문을 처리한 뒤, `200 OK`가 아닌 `302 Redirect` 응답을 보냅니다. (응답 헤더: `Location: /order/complete/123`)
3.  **G (GET):** 브라우저는 `302` 응답을 받고, `Location`에 적힌 주소로 **자동으로 `GET` 요청**을 다시 보냅니다.

- **결과:** 사용자는 `GET /order/complete/123` (주문 완료 '조회' 페이지)를 보게 됩니다. 이 페이지에서 새로고침을 해도 `POST`가 아닌 `GET` 요청이 반복될 뿐이므로, 주문이 중복되지 않습니다.

<br>

### 4xx (Client Error) : 클라이언트 요청에 문제가 있음.

- `400 Bad Request`: 요청 형식이 잘못됨.
- `401 Unauthorized`: **인증(Authentication)** 필요. (로그인 안 함)
- `403 Forbidden`: **권한(Authorization)** 없음. (로그인은 했지만, 관리자 페이지 접근 시도)
- `404 Not Found`: 요청한 리소스를 찾을 수 없음.

  <br>

### 5xx (Server Error) : 서버 내부 문제.

- `500 Internal Server Error`: 서버 코드 로직, DB 오류 등.

---

## 6. HTTP 헤더

HTTP 메시지에 포함되는 부가 정보입니다. (Key-Value)

### 표현 (Representation) 헤더

- `Content-Type`: 내가 보내는 데이터가 어떤 형식인지 (e.g., `application/json`, `text/html`)
- `Accept`: (요청 시) 내가 받을 수 있는 형식이 무엇인지

### 캐시 (Cache) 헤더

**[예시: 게시판 공지사항 확인하기]**

- **`Cache-Control: max-age=60`**
  "이 공지사항은 60초 동안은 최신 버전이니, 60초 동안은 나(서버)에게 다시 묻지 말고 그냥 네가 저장한(캐시) 공지사항을 봐."

- **`ETag` (Entity Tag) / `If-None-Match`**
  `max-age` 시간이 지난 후, 캐시가 유효한지 '검증'하는 방법입니다.

  1.  **최초 요청 :** 클라이언트가 공지사항을 `GET` 요청. 서버는 응답 시 공지사항의 '버전 태그'를 함께 보냅니다. (`ETag: "v1.0"`)
  2.  **클라이언트 :** 공지사항 내용과 `ETag: "v1.0"`을 함께 캐시(저장)합니다.
  3.  **이후 요청:** `max-age`가 만료된 후, 클라이언트는 서버에 `GET` 요청을 보내며 헤더에 `If-None-Match: "v1.0"` (내가 가진 버전)을 실어 보냅니다.
  4.  **서버 검증**
      - **Case 1 (수정 안 됨) :** 서버가 가진 버전도 `v1.0`이면, **`304 Not Modified`** 라는 응답만 보냅니다. (본문 데이터 X)
        -> 클라이언트는 "아, 내가 가진 거 그대로 쓰면 되는구나"라고 판단하고 캐시를 재사용합니다. (네트워크 트래픽 절약!)
      - **Case 2 (수정됨) :** 서버가 가진 버전이 `v2.0`으로 바뀌었으면, **`200 OK`** 응답과 함께 새로운 공지사항 본문과 `ETag: "v2.0"`을 보냅니다.
        -> 클라이언트는 캐시를 새 버전으로 교체합니다.

---

## 7. HTTPS와 보안

### ① HTTPS: 보안 계층 (암호화)

- **HTTP (Postcard):** 그냥 엽서를 보내는 것과 같습니다. 중간에 누구나(해커) 훔쳐볼 수 있습니다.
- **HTTPS (Safe Box):**
  - 데이터를 '잠금장치가 달린 안전한 상자'에 넣어 보내는 것과 같습니다. (SSL/TLS 암호화)
  - 중간에 누군가 상자를 가로채도, 열쇠(암호화 키)가 없으면 안의 내용을 볼 수 없습니다.

### ② 쿠키 보안 속성 (HttpOnly, SameSite)

쿠키를 발급(`Set-Cookie`)할 때, 이 옵션들을 설정하지 않으면 심각한 보안 위협에 노출될 수 있습니다.

- **`HttpOnly`: JS 손길이 닿지 않는 쿠키**
  - 이 옵션이 있으면, `document.cookie` 같은 자바스크립트 명령어로 쿠키를 조회/조작할 수 없습니다.
  - **목적:** XSS 공격(악성 스크립트)으로 인해 사용자의 로그인 쿠키(자유이용권 팔찌)를 도둑맞는 것을 방지합니다. (필수!)
- **`SameSite` (Strict / Lax / None): 테마파크 안에서만 유효한 팔찌**
  - 다른 사이트(e.g., 악성 사이트)에서 우리 사이트(e.g., 은행)로 요청을 보낼 때, 쿠키를 보낼지 말지 결정하는 정책입니다.
  - **목적:** CSRF 공격(요청 위조)을 방지합니다. (e.g., 내가 누른 악성 링크가 나도 모르게 내 은행 쿠키를 싣고 '송금' 요청을 보내는 것을 막아줍니다.)

### ③ CORS (교차 출처 리소스 공유)

**웹 개발자가 가장 많이 마주치는 4xx 에러 중 하나입니다.**

- **기본 정책 (SOP):** 브라우저는 보안을 위해 **"동일 출처 정책(Same-Origin Policy)"** 을 따릅니다.

  - `https://www.google.com` (A출처)에서 실행된 코드는 `https://www.naver.com` (B출처)의 API를 호출할 수 없습니다.

- **문제:** 현대 웹은 API 서버(`api.my-app.com`)와 프론트엔드 서버(`www.my-app.com`)를 분리하는 것이 일반적이라, **출처가 다를 수밖에 없습니다.**

- **해결 (CORS)**
  - 서버가 HTTP 응답 헤더에 "내 자원은 `https://www.my-app.com` 출처에서도 가져가도 좋아"라고 **허락**해주는 메커니즘입니다.
  - `Access-Control-Allow-Origin: https://www.my-app.com`
- **Preflight (사전 요청):** `POST`, `PUT` 등 '위험한' 요청 전에, 브라우저는 `OPTIONS` 메서드로 "내가 이런 요청 보낼 건데 괜찮아?"라고 먼저 물어봅니다. 서버가 여기서 "OK"해야 본 요청이 나갑니다.

---

## 8. RESTful API 디자인 스타일 (REST)

HTTP의 기능을 활용하여 API를 '잘 디자인하는 방법론(아키텍처 스타일)'입니다.

**핵심 원칙**

1.  **자원(Resource):** URI는 '자원'을 명시해야 합니다. (e.g., `/members`, `/members/1`)
2.  **행위(Method):** '행위'는 HTTP 메서드(GET, POST, PUT, DELETE)로 표현해야 합니다.
    - (나쁜 예: `GET /getMember/1`, `POST /createMember`)
    - (좋은 예: `GET /members/1`, `POST /members`)
3.  **HATEOAS (자기 서술적):** 응답에 '다음에 할 수 있는 행동'에 대한 링크를 포함시켜야 합니다.

**[예시: HATEOAS]**

`GET /members/1` 요청에 대한 응답이 단순 정보만 주는 것이 아니라, 관련된 다음 행동(링크)을 함께 제공합니다.

```json
// GET /members/1 에 대한 응답
{
  "id": 1,
  "name": "홍길동",
  "links": [
    { "rel": "self", "href": "/members/1" },
    { "rel": "edit", "href": "/members/1", "method": "PUT" },
    { "rel": "delete", "href": "/members/1", "method": "DELETE" },
    { "rel": "orders", "href": "/members/1/orders" }
  ]
}
```

클라이언트는 이 `links` 정보를 보고 "아, 이 회원을 수정하려면 `links` 배열에서 `rel: "edit"`인 링크로 `PUT` 요청을 보내면 되는구나"라고 스스로 판단할 수 있습니다.
